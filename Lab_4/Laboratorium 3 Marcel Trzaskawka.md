# Zaawansowana Analiza Statyczna

## Wstęp

Laboratorium pokazuje w jaki sposób przeprowadzić zaawansowaną analizę statyczną za pomocą IDA Free/Pro.

## Table Of Contents

- [Zaawansowana Analiza Statyczna](#zaawansowana-analiza-statyczna)
  - [Wstęp](#wstęp)
  - [Table Of Contents](#table-of-contents)
  - [Hashe](#hashe)
  - [Struct Cheatsheet](#struct-cheatsheet)
    - [if statement](#if-statement)
    - [Nested if statement](#nested-if-statement)
    - [for loop](#for-loop)
    - [Przed rozpoczęciem analizy](#przed-rozpoczęciem-analizy)
  - [Laboratorium 4.1](#laboratorium-41)
    - [Adres DllMain](#adres-dllmain)
    - [Adres gethostbyname](#adres-gethostbyname)
    - [Wywołania gethostbyname](#wywołania-gethostbyname)
    - [DNS Request](#dns-request)
    - [Zmienne lokalne 10001656h](#zmienne-lokalne-10001656h)
    - [Parametry 10001656h](#parametry-10001656h)
    - [Adres \\cmd.exe /c](#adres-cmdexe-c)
    - [Co się dzieje w otoczeniu tego adresu](#co-się-dzieje-w-otoczeniu-tego-adresu)
    - [Zmienna dword\_1008E5C4](#zmienna-dword_1008e5c4)
    - [Adres 1000FF58h](#adres-1000ff58h)
    - [Eksport PLIST](#eksport-plist)
    - [sub\_10004E79](#sub_10004e79)
    - [DllMain](#dllmain)
    - [Sleep](#sleep)
    - [Socket](#socket)
    - [in](#in)
    - [Adres 1001D988h](#adres-1001d988h)
  - [Laboratorium 4.2](#laboratorium-42)
    - [Struktura Main](#struktura-main)
    - [0x40105F](#0x40105f)
    - [Co się dzieje w programie](#co-się-dzieje-w-programie)
  - [Laboratorium 4.3](#laboratorium-43)
    - [Main](#main)
    - [sub\_40117F](#sub_40117f)
    - [Drugi podprogram](#drugi-podprogram)
    - [Indykatory sieciowe](#indykatory-sieciowe)
    - [Działanie](#działanie)

## Hashe

| Plik | SHA-256 | VirusTotal |
| ---- | ------- | ---------- |
| Lab04-01.dll | EB1079BDD96BC9CC19C38B76342113A09666AAD47518FF1A7536EEBFF8AADB4A | 59/69 |
| Lab04-01.py | C274FEB297E0044E21C7CA3EDDA95ED60F86AB6A87CDF8CE571A5143B913AF08 | 0/57 |
| Lab05-01.exe | FE30F280B1D0A5E9CEF3324C2E8677F55A6202599D489170ECE125F3CD843A03 | 1/69 |
| Lab05-02.exe | B71777EDBF21167C96D20FF803CBCB25D24B94B3652DB2F286DCD6EFD3D8416A | 39/70 |

## Struct Cheatsheet

### if statement

Prosta struktura - porównywanie dwóch wartości, a następnie skok warunkowy.

```x86asm
mov eax sth1
cmp eax sth2
jnz loc
```

### Nested if statement

2 zagnieżdżone ify dają 4 różne ścieżki:  

- Oba będą prawdziwe
- Tylko pierwszy będzie prawdziwy
- Tylko drugi będzie prawdziwy
- Żaden nie będzie prawdziwy

Komplikuje to strukturę kodu, lecz pojawi się sporo porównań i skoków warunkowych np.

```x86asm
cmp ... ...
jnz loc_1
cmp ... ...
jnz loc_2
...
jmp loc_4

loc_1:
...
loc_2:
...

...
loc_4:
*code continnues*
```

### for loop

Pętla for inicjuje wartość początkową i dopóki nie spełni się określowy warunek kod będzie skakał do tego samego miejsca (jak w pętli :p).

Przykład:

```x86asm
mov [ebp+var_ini], 0 ; [] oznacza lokalizację w pamięci
jmp loc_1

loc_2: ; inkrementacja
mov eax, [ebp+var_ini]
add eax, 1
mov [ebp+var_ini], eax

loc_1: ; kod w pętli
cmp [ebp+var], 20h ; wartość końcowa
jge loc_3
...
jmp loc_2
```

### Przed rozpoczęciem analizy

- Załadować plik z sygnaturami FLIRT (vc32rtf)
- Odszukać funkcję `main`
- Zaznaczyć *Line Prefixes (Graph)* w opcjach
- Popatrzeć na **header** i **importy**

## Laboratorium 4.1

### Adres DllMain

IDA Free nie potrafi rozpoznać funnkcji `DllMain` a jedynie **DllEntryPoint**.

Adres `DllMain` znajduje się na pozycji *000000001001516Dh*.

Aby odnaleźć `DllMain` trzeba załadować plik FLIRT, a dokładniej *vc32rtf*.

Po sprawdzeniu zakładki *Function Calls* widać kilka funkcji z czego tylko 2 rzeczy nie są oznaczone jako *library function*.  
*dword_10092E58* jest tylko wskaźnikiem, więc `DllMain` musi być funkcja **`sub_1000D02E`**, która znajduje się pod tym właśnie adresem.

![DllMain Adress](img/1.png)

![DllMain Adress](img/25.png)

![Atribute: library function](img/26.png)

Po zmianie nazwy funkcji wygląda ona teraz tak:

![DllMain](img/27.png)

### Adres gethostbyname

Funkcja `gethostbyname` znajduje się pod adresem *00000000100163CCh*.

![gethosybyname Adress](img/2.png)

### Wywołania gethostbyname

Funkcja `gethostbyname` została wywołana **18 razy**.

![gethostbyname xrefs](img/3.png)

### DNS Request

Przed wykonaniem funkcji do rejestru jest zapisana zmienna *"[This is RDO]pics.practicalmalwareanalysis.com"*, a następnie została przesunięta o 0Dh  znaków, czyli 13 co daje `pics.practicalmalwareanalysis.com`.

![DNS Request](img/4.png)

![off_10019040](img/5.png)

### Zmienne lokalne 10001656h

IDA rozpoznała dla funkcji `sub_10001656` **23 zmienne lokalne** (*offset ujemny, ponieważ są znajdują się pod EBP. Zmienne lokalne zapisywane są na stacku po zmianie EBP przy wywołaniu funkcji więc znajdują się wyżej*).

![Local Variables and Parameters table](img/31.png)

### Parametry 10001656h

Funkcja `sub_10001656` posiada **jeden parametr** (*offset dodatni*).

![sub_10001656 Local Variables and Parameter](img/6.png)

### Adres \cmd.exe /c

String *"\cmd.exe /c"* znajduje się pod adresem **10095B34h**.

### Co się dzieje w otoczeniu tego adresu

Przeglądając graf na samym początku tej funkcji znajduje się duży string, który zawiera wiadomość. Znajdują się w niej informacje o ***szyfrowaniu magicznego numeru (Encrypt Magic Number)*** oraz ***Remote Shell Session***.

![Remote Shell Session](img/9.png)

Program porównuje wersje systemu i w zależności od niej wywołuje **"\cmd.exe /c"** lub **"/command.exe /c"**.

![Comparison](img/11.png)

*dwPlatformId* równe 2 oznacza *VER_PLATFORM_WIN32_NT* co oznacza, że system jest **Windows NT lub nowszy**.

![dwPlatformId](img/13.png)

![cmd/command](img/10.png)

***/c*** jako opcja oznacza, że wykona się komenda podana w stringu  
Program łączy stringi za pomocą funkcji `strcat`.

![strcat](img/12.png)

Dalej w funkcji znajdują się stringi takie jak:

- quit
- exit
- cd
- enmagic
- language
- install
- host
- inject

Najprawdopodbniej są to komendy, ze wzglęgu na wcześniejszą wiadomość z ***Remote Shell Session***.

### Zmienna dword_1008E5C4

Zmienna *dword_1008E5C4* została opisana [powyżej](#co-się-dzieje-w-otoczeniu-tego-adresu)

### Adres 1000FF58h

Jeżeli porównanie *'robotwork'* zwróci **wartość zero** (*`eax` będzie miało tą samą wartość*) skok warunkowy nie wykona się i program będzie wykonywał się dalej (*w tym przypadku pójdzie ścieżką czerwoną w lewo*).

![robotwork](img/14.png)

Wykona się tam funkcja `sub100052A2`, która przyjmuje socket jako argument.

![sub_100052A2 function](img/15.png)

Funkcja ta wykonuje następujące operacje:

- Otwiera rejestr ***HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion***
- Następnie klucz Worktime/Worktimes
- Z tego klucza wyciąga informacje i wysyła je zdalnemu hostowi za pomocą funkcji `sub_100038EE`.

![Registry Key](img/18.png)

![Reg info sent](img/19.png)

### Eksport PLIST

Na początku funkcja sprawdza wersję systemu, lecz tym razem sprawdzając czy *Majorversion* jest **większa niż 5** (*czyli wersja nowsza lub równa Windows 2000*).

![Sysversion Check](img/16.png)

![Sysversion Major Version](img/17.png)

W tym miejscu funkcja sprawdza, czy jako parametr został podany string. W obu przypadkach obie funkcje enumerują Wszystkie atywne procesy. Na początku wykonuje snapshot procesów za pomocą ***`CreateToolhelp32Snapshot`***,

![CreateToolhelp32Snapshot](img/22.png)

**`Process32First`**, aby wyciągnąć ze snapshota pierwszy proces, a następnie w pętli while **`Process32Next`**.

![While loop](img/23.png)

Funkcja pozyskuje również informacje o tym do jakiego pliku należy dany proces za pomocą **`GetModuleFileNameEx`**, wszystko w czytelnym formacie.

![While loop](img/21.png)

### sub_10004E79

Funkcja wywołuje funkcję `GetSystemDefaultLangID`, która zwraca *ID* domyślnie ustawionego języka systemowego, a następnie go wysyła zdalnemu hostowi.

![GetSystemDefaultLangID](img/24.png)

Wszystkie ID są rozpisane przez Microsoft [tutaj](https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-LCID/%5bMS-LCID%5d.pdf)  
Dla przykładu język polski ma przypisane ID **0x0015** lub **0x0415**, a angielski **0x0009**, **0x0409** (odmiana amerykańska) lub **0x0809** (odmiana brytyjska) itd.

Funkcja mogłaby przyjąć nazwę ***SendDefaultLangID*** bądź ***RetrieveDefaultLangID***.

### DllMain

Aby dowiedzieć się ile wywołań ma `DllMain` najlepszym rozwiązaniem jest stworzenie grafu np. z takimi ustawieniami:

![User Graph](img/28.png)

DllMain używa bezpośrednio **7 funkcji**:

![Graph DllMain Recursion 1](img/29.png)

Używając głębokości 2 (*Jeżeli nie popełniłem błędu w liczeniu*) używa **66 funkcji**:

![Graph DllMain Recursion 2](img/30.png)

### Sleep

Przed wywołaniem funkcji najpierw musi ona przyjąć parametry. Dzieje się to za pomocą `push`. Musimy w takim razie sprawdzić jaką wartość będzie miał rejestr `eax`.

Zaczyna się od tego, że do rejestru eax zapisana jest offset stringa ***"[This is CTI]30"***.

Do offsetu następnie jest dodana **wartość 0Dh** (*13*) co sprawia, że string to teraz ***"30"***.

`push eax` wrzuca `eax` na *stack*, gdzie następnie jest wywołana funkcja `atoi`, która w języku *C++* zamienia string na liczbę. Tak więc funckja zwraca **wartość 30**. Według poniższej tabelki `eax` jest rejestrem, który przychowuje pierwszą zwróconą wartość.

![Registry Usage Table](img/32.png)

Następnie wartość zostaje pomnożona przez **3E8h** ($3 \cdot 16^2 + 14 \cdot 16 + 8$) czyli **1000**.

Ta wartość jest przyjmowana jako parametr przez funckcję `Sleep`, która przyjmuje czas w milisekundach. To oznacza, że program śpi przez ***30 sekund***.

### Socket

Funkcja Socek przyjmuje 3 parametry:

- int *af*
- int *type*
- int *protocol*

Według dokumentacji Microsoft  

- *af* oznacza address family
- *type* oznacza typ socketa
- *protocol* oznacza użyty protokół

W tym miejscu odwołanie w pseudo C/C++ wyglądało by tak:

```C
socket(2, 1, 6)
```

Co oznacza utworzony socket z address family **AF_INET** (*Adres IPv4*), type **SOCK_STREAM** (*Two way connection, przy AF_INET TCP*) i protokołem **IPPROTO_TCP**.

### in

Po wyszukaniu każdej linii zawierającej *EDh* znalazłem tylko jeden adres w którym została użyta funkcja `in`.

![in Address](img/34.png)

Funckcja `in` używa dwóch rejestrów: `eax` (*Magic Value*) oraz `dx` (*port*).

Po kliknięciu na wartość *564D5868h* i kliknięciu klawisza R ukazuje nam się string *"VMXh"*, a w `edx` *"VX"*.

Po instrukcji `in` jest instrukcja `cmp ebx, 'VMXh'`, która sprawdza czy otrzymano odpowiedź od portu **VMware**.

Program jest zatem w stanie wykryć obecność w maszynie wirtualnej.

Po wykonaniu funkcji znajduje się też string *"Found Virtual Machine, Install Cancel."*.

### Adres 1001D988h

Pod tym adresem znajdują się losowe dane. Jednak w książce odpowiednik tego zadania wskazuje na użycie skryptu w pythonie. Niestety w *IDA Free* nie da się używać takich skryptów. Skrypt jedyne co robi to xoruje każdy znak z *55h*, więc zrobiłem to ręcznie używając [Cyberchef](https://cyberchef.org/#recipe=From_Hex('Auto')XOR(%7B'option':'Hex','string':'55'%7D,'Standard',false)&input=MkQgMzEgM2EgM2EgMjcgNzUgCjNjIDI2IDc1IDIxIDNkIDNjIDI2IDc1IAozNyAzNCAzNiAzZSAzMSAzYSAzYSAyNyA3OSA3NSAKMjYgMjEgMjcgM2MgM2IgMzIgNzUgCjMxIDMwIDM2IDNhIDMxIDMwIDMxIDc1IAozMyAzYSAyNyA3NSAwNSAyNyAzNCAzNiAyMSAzYyAzNiAzNCAzOSA3NSAKMTggMzQgMzkgMjIgMzQgMjcgMzAgNzUgCjE0IDNiIDM0IDM5IDJjIDI2IDNjIDI2IDc1IAoxOSAzNCAzNyA3NSAKNmYgN2MgNjQgNjcgNjYgNjE).

![Cyberchef decoded](img/36.png)

## Laboratorium 4.2

### Struktura Main

Niestety *IDA Free* nie znajduje automatycznie funkcji `main`, więc musiałem znaleźć ją ręcznie.

Pozaładowaniu pliku z sygnaturami *FLIRT*, *IDA* rozpoznała niektóre funkcje.

Aby znaleźć `Main` zacząłem szukania od końca, ponieważ każda funkcja `Main` zwraca **0** (*kiedy program zakończy się bez błędów*). **0** będzie się znajdowało w rejestrze `eax`, ponieważ jest to rejestr dla pierwszej zwracanej wartości (*W tym wypadku również jedynej*).

Pierwsza funkcja od końca to `__XcptFilter`, która zajmuje się ***exception handling***, a następnie funkcja `_exit`, która ***zabija procesy***, więc nie są to interesujące mnie funckje.

Następna w kolejce jest funkcja `sub_401040`, która przyjmuje **3** argumenty co wygląda obiecująco (*Według Microsoft main przyjmuje argumenty `argc`, `argv` oraz może zostać rozszerzony o argument zawierający zmienne środowiskowe `envp`*).

Patrząc od końca na tą funckję widać dwie różne ścieżki:

- W jednej jest instrukcja `xor eax, eax` co zeruje rejestr `eax`
- W drugiej rejestr jest instrukcja `mov eax, 1`, czyli `eax` posiada wartość 1 (~~błąd~~)

Po przeanalizowaniu funkcji `sub_402580`, nie znalazłem rzeczy wskazujących na to, żeby była to funkcja `main`.

Co więcej bezpośrednio przed wywołaniem `sub_401040` występują funkcje takie jak `__setargv, __setenvp` dzięki czemu wiem, że `sub_401040` jest funckją `main`.

![main function](img/38.png)  

![inside main function](img/39.png)  

Zaglądając do środka funkcji `main` widąć jedną funkcję `sub_401000`.
Funkcja jest bardzo prosta. Znajduje się w niej tylko jeden *if* oraz funkcja `InternetGetConnectionStatus`, która nie robi nic innego niż sprawdza czy system jest podłączony do sieci.

Według dokumentacji Microsoftu funkcja zwraca **TRUE** (*1*), kiedy maszyna jest podłączona do internetu, albo **FALSE** (*0*) kiedy nie jest.

W wypadku kiedy funkcja **zwróci 1**, `cmp [ebp+InternetConnectionStatus], 0` (*nazwa zmiennej zmieniona przeze mnie*) ustawi flagę **ZF = 0**, przez co program pójdzie ścieżką czerwoną (*false*). Na koniec do rejestru `eax` przypisana jest **wartość 1**.

Wracając do funkcji `main` widać, że `eax` jest **porównany z 0** i w przypadku kiedy maszyna jest podłączona do sieci funkcja `main` **zwróci 1** (*Nie wiem dlaczego nie **0**, zwykle niezerowa wartość oznacza błąd*).

![sub_401000](img/37.png)

### 0x40105F

Funkcja wygląda dziwnie, ale uwagę przykuwają dwie funckje, które są funkcjami biblioteki ***Libc***: `__stbuf` oraz `__ftbuf`.

Po przeszukaniu internetu natknąłem się na [wpis na forum](https://social.msdn.microsoft.com/Forums/vstudio/en-US/838011e2-7404-4922-989e-3ceacd6e3127/how-about-the-function-stbufstdout-woks-?forum=vclanguage). Okazuje się, że obie funkcje wykorzystywane są przez funkcję `printf`.

Najwidoczniej *IDA* nie rozpoznała tej funkcji.

![sub_40105F](img/41.png)

![printf](img/40.png)

### Co się dzieje w programie

Więcej funkcji jest automatycznie wygenerowana przez kompilator (*Funkcje manipulujące stertą `HeapCreate` `HeapDestroy`, `memset`*), więc program po prostu sprawdza czy maszyna jest podpięta do internetu i w zależności od tego wypisuje jeden ze stringów.

- **Success: Internet Connection\n**
- **Error 1.1: No Internet\n**

## Laboratorium 4.3

### Main

Tak jak przy poprzednim ~~wirusie~~ programie zlokalizowałem funkcję `main` pod adresem **401130h**.

Pierwszy podprogram funkcji `main` to funkcja `sub_401000`. Jest to identyczna funkcja jak w poprzednim programie, która sprawdza czy maszyna jest podłączona do internetu.

Znajduje się w niej również tajemnicza funkcja `sub_40117F`, która jest funkcją `printf`.

### sub_40117F

Opisane wyżej 😃👍

### Drugi podprogram

Drugi podprogram to funkcja `sub_401040`.

Wywołuje ona funkcję `InternetOpenA`, która otwiera przeglądarkę (w tym przypadku *Internet Explorer 7.5/pma*). Funkcja następnie zwraca *Handle* do otwartej przeglądarki.

Następna funkcja to `InterenOpenUrlA`, która przyjmuje wcześniej zwrócony *Handle* oraz URL ***`http://www.practicalmalwareanalysis.com/cc.htm`***.
W wypadku kiedy nie uda się połączyć ze stroną Handle jest zamykana.

Po połączeniu ze stroną program odczytuje jej zawartość za pomocą `InternetReadFile`. Zawartość jest zapisana do bufora pod adresem **`[ebp+Buffer]`**, a ilość bajtów odczytanych pod adresem **`[ebp+dwNumberOfBytesRead]`**. Funkcja odczytuje 200h bajtów czyli 512 bajtów.

Następnie mamy kilka porównań bajtów z bufora. zmienne *`var_20F`* do *`var_20D`* odpowiadają kolejnym bajtom z bufora ponieważ bufor znajduje się na **pozycji -210**. Dzięki temu wiemy, że bufor zaczyna się od `<!--` czyli od początku **komentarza html**. Jeżeli któryś z bajtów nie będzie się zgadzał, funkcja zwraca błąd ***Error 2.3: Fail to get command\n***. Na koniec piąty znak z bufora jest zapisany do rejestru `al`, a następnie zwrócony przez tą funkcję.

![Second function](img/42.png)

![InternetOpenA](img/43.png)

![InternetReadFile](img/44.png)

### Indykatory sieciowe

Dwa indykatory sieciowe to przeglądarka `Internet Explorer 7.5/pma` oraz adres `http://practicalmalwareanalysis.com/cc.htm`.

### Działanie

Wirus najpierw sprawdza czy maszyna jest połączona z internetem.

Jeżeli tak to włącza przeglądarkę, łączy się ze stroną internetową i następnie pobiera z niej określoną zawartość.

Na koniec program wypisuje jaka to komenda `Success Parsed command is %c\n`.

Na koniec program jest uśpiony przez **0EA60h** milisekund czyli **jedną minutę**.

Program kończy swoje działanie.
