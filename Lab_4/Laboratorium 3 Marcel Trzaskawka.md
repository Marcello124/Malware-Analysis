# Zaawansowana Analiza Statyczna

## Wstp

Laboratorium pokazuje w jaki spos贸b przeprowadzi zaawansowan analiz statyczn za pomoc IDA Free/Pro.

## Table Of Contents

- [Zaawansowana Analiza Statyczna](#zaawansowana-analiza-statyczna)
  - [Wstp](#wstp)
  - [Table Of Contents](#table-of-contents)
  - [Hashe](#hashe)
  - [Struct Cheatsheet](#struct-cheatsheet)
    - [if statement](#if-statement)
    - [Nested if statement](#nested-if-statement)
    - [for loop](#for-loop)
    - [Przed rozpoczciem analizy](#przed-rozpoczciem-analizy)
  - [Laboratorium 4.1](#laboratorium-41)
    - [Adres DllMain](#adres-dllmain)
    - [Adres gethostbyname](#adres-gethostbyname)
    - [Wywoania gethostbyname](#wywoania-gethostbyname)
    - [DNS Request](#dns-request)
    - [Zmienne lokalne 10001656h](#zmienne-lokalne-10001656h)
    - [Parametry 10001656h](#parametry-10001656h)
    - [Adres \\cmd.exe /c](#adres-cmdexe-c)
    - [Co si dzieje w otoczeniu tego adresu](#co-si-dzieje-w-otoczeniu-tego-adresu)
    - [Zmienna dword\_1008E5C4](#zmienna-dword_1008e5c4)
    - [Adres 1000FF58h](#adres-1000ff58h)
    - [Eksport PLIST](#eksport-plist)
    - [sub\_10004E79](#sub_10004e79)
    - [DllMain](#dllmain)
    - [Sleep](#sleep)
    - [Socket](#socket)
    - [in](#in)
    - [Adres 1001D988h](#adres-1001d988h)
  - [Laboratorium 4.2](#laboratorium-42)
    - [Struktura Main](#struktura-main)
    - [0x40105F](#0x40105f)
    - [Co si dzieje w programie](#co-si-dzieje-w-programie)
  - [Laboratorium 4.3](#laboratorium-43)
    - [Main](#main)
    - [sub\_40117F](#sub_40117f)
    - [Drugi podprogram](#drugi-podprogram)
    - [Indykatory sieciowe](#indykatory-sieciowe)
    - [Dziaanie](#dziaanie)

## Hashe

| Plik | SHA-256 | VirusTotal |
| ---- | ------- | ---------- |
| Lab04-01.dll | EB1079BDD96BC9CC19C38B76342113A09666AAD47518FF1A7536EEBFF8AADB4A | 59/69 |
| Lab04-01.py | C274FEB297E0044E21C7CA3EDDA95ED60F86AB6A87CDF8CE571A5143B913AF08 | 0/57 |
| Lab05-01.exe | FE30F280B1D0A5E9CEF3324C2E8677F55A6202599D489170ECE125F3CD843A03 | 1/69 |
| Lab05-02.exe | B71777EDBF21167C96D20FF803CBCB25D24B94B3652DB2F286DCD6EFD3D8416A | 39/70 |

## Struct Cheatsheet

### if statement

Prosta struktura - por贸wnywanie dw贸ch wartoci, a nastpnie skok warunkowy.

```x86asm
mov eax sth1
cmp eax sth2
jnz loc
```

### Nested if statement

2 zagnie偶d偶one ify daj 4 r贸偶ne cie偶ki:  

- Oba bd prawdziwe
- Tylko pierwszy bdzie prawdziwy
- Tylko drugi bdzie prawdziwy
- 呕aden nie bdzie prawdziwy

Komplikuje to struktur kodu, lecz pojawi si sporo por贸wna i skok贸w warunkowych np.

```x86asm
cmp ... ...
jnz loc_1
cmp ... ...
jnz loc_2
...
jmp loc_4

loc_1:
...
loc_2:
...

...
loc_4:
*code continnues*
```

### for loop

Ptla for inicjuje warto pocztkow i dop贸ki nie speni si okrelowy warunek kod bdzie skaka do tego samego miejsca (jak w ptli :p).

Przykad:

```x86asm
mov [ebp+var_ini], 0 ; [] oznacza lokalizacj w pamici
jmp loc_1

loc_2: ; inkrementacja
mov eax, [ebp+var_ini]
add eax, 1
mov [ebp+var_ini], eax

loc_1: ; kod w ptli
cmp [ebp+var], 20h ; warto kocowa
jge loc_3
...
jmp loc_2
```

### Przed rozpoczciem analizy

- Zaadowa plik z sygnaturami FLIRT (vc32rtf)
- Odszuka funkcj `main`
- Zaznaczy *Line Prefixes (Graph)* w opcjach
- Popatrze na **header** i **importy**

## Laboratorium 4.1

### Adres DllMain

IDA Free nie potrafi rozpozna funnkcji `DllMain` a jedynie **DllEntryPoint**.

Adres `DllMain` znajduje si na pozycji *000000001001516Dh*.

Aby odnale藕 `DllMain` trzeba zaadowa plik FLIRT, a dokadniej *vc32rtf*.

Po sprawdzeniu zakadki *Function Calls* wida kilka funkcji z czego tylko 2 rzeczy nie s oznaczone jako *library function*.  
*dword_10092E58* jest tylko wska藕nikiem, wic `DllMain` musi by funkcja **`sub_1000D02E`**, kt贸ra znajduje si pod tym wanie adresem.

![DllMain Adress](img/1.png)

![DllMain Adress](img/25.png)

![Atribute: library function](img/26.png)

Po zmianie nazwy funkcji wyglda ona teraz tak:

![DllMain](img/27.png)

### Adres gethostbyname

Funkcja `gethostbyname` znajduje si pod adresem *00000000100163CCh*.

![gethosybyname Adress](img/2.png)

### Wywoania gethostbyname

Funkcja `gethostbyname` zostaa wywoana **18 razy**.

![gethostbyname xrefs](img/3.png)

### DNS Request

Przed wykonaniem funkcji do rejestru jest zapisana zmienna *"[This is RDO]pics.practicalmalwareanalysis.com"*, a nastpnie zostaa przesunita o 0Dh  znak贸w, czyli 13 co daje `pics.practicalmalwareanalysis.com`.

![DNS Request](img/4.png)

![off_10019040](img/5.png)

### Zmienne lokalne 10001656h

IDA rozpoznaa dla funkcji `sub_10001656` **23 zmienne lokalne** (*offset ujemny, poniewa偶 s znajduj si pod EBP. Zmienne lokalne zapisywane s na stacku po zmianie EBP przy wywoaniu funkcji wic znajduj si wy偶ej*).

![Local Variables and Parameters table](img/31.png)

### Parametry 10001656h

Funkcja `sub_10001656` posiada **jeden parametr** (*offset dodatni*).

![sub_10001656 Local Variables and Parameter](img/6.png)

### Adres \cmd.exe /c

String *"\cmd.exe /c"* znajduje si pod adresem **10095B34h**.

### Co si dzieje w otoczeniu tego adresu

Przegldajc graf na samym pocztku tej funkcji znajduje si du偶y string, kt贸ry zawiera wiadomo. Znajduj si w niej informacje o ***szyfrowaniu magicznego numeru (Encrypt Magic Number)*** oraz ***Remote Shell Session***.

![Remote Shell Session](img/9.png)

Program por贸wnuje wersje systemu i w zale偶noci od niej wywouje **"\cmd.exe /c"** lub **"/command.exe /c"**.

![Comparison](img/11.png)

*dwPlatformId* r贸wne 2 oznacza *VER_PLATFORM_WIN32_NT* co oznacza, 偶e system jest **Windows NT lub nowszy**.

![dwPlatformId](img/13.png)

![cmd/command](img/10.png)

***/c*** jako opcja oznacza, 偶e wykona si komenda podana w stringu  
Program czy stringi za pomoc funkcji `strcat`.

![strcat](img/12.png)

Dalej w funkcji znajduj si stringi takie jak:

- quit
- exit
- cd
- enmagic
- language
- install
- host
- inject

Najprawdopodbniej s to komendy, ze wzglgu na wczeniejsz wiadomo z ***Remote Shell Session***.

### Zmienna dword_1008E5C4

Zmienna *dword_1008E5C4* zostaa opisana [powy偶ej](#co-si-dzieje-w-otoczeniu-tego-adresu)

### Adres 1000FF58h

Je偶eli por贸wnanie *'robotwork'* zwr贸ci **warto zero** (*`eax` bdzie miao t sam warto*) skok warunkowy nie wykona si i program bdzie wykonywa si dalej (*w tym przypadku p贸jdzie cie偶k czerwon w lewo*).

![robotwork](img/14.png)

Wykona si tam funkcja `sub100052A2`, kt贸ra przyjmuje socket jako argument.

![sub_100052A2 function](img/15.png)

Funkcja ta wykonuje nastpujce operacje:

- Otwiera rejestr ***HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion***
- Nastpnie klucz Worktime/Worktimes
- Z tego klucza wyciga informacje i wysya je zdalnemu hostowi za pomoc funkcji `sub_100038EE`.

![Registry Key](img/18.png)

![Reg info sent](img/19.png)

### Eksport PLIST

Na pocztku funkcja sprawdza wersj systemu, lecz tym razem sprawdzajc czy *Majorversion* jest **wiksza ni偶 5** (*czyli wersja nowsza lub r贸wna Windows 2000*).

![Sysversion Check](img/16.png)

![Sysversion Major Version](img/17.png)

W tym miejscu funkcja sprawdza, czy jako parametr zosta podany string. W obu przypadkach obie funkcje enumeruj Wszystkie atywne procesy. Na pocztku wykonuje snapshot proces贸w za pomoc ***`CreateToolhelp32Snapshot`***,

![CreateToolhelp32Snapshot](img/22.png)

**`Process32First`**, aby wycign ze snapshota pierwszy proces, a nastpnie w ptli while **`Process32Next`**.

![While loop](img/23.png)

Funkcja pozyskuje r贸wnie偶 informacje o tym do jakiego pliku nale偶y dany proces za pomoc **`GetModuleFileNameEx`**, wszystko w czytelnym formacie.

![While loop](img/21.png)

### sub_10004E79

Funkcja wywouje funkcj `GetSystemDefaultLangID`, kt贸ra zwraca *ID* domylnie ustawionego jzyka systemowego, a nastpnie go wysya zdalnemu hostowi.

![GetSystemDefaultLangID](img/24.png)

Wszystkie ID s rozpisane przez Microsoft [tutaj](https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-LCID/%5bMS-LCID%5d.pdf)  
Dla przykadu jzyk polski ma przypisane ID **0x0015** lub **0x0415**, a angielski **0x0009**, **0x0409** (odmiana amerykaska) lub **0x0809** (odmiana brytyjska) itd.

Funkcja mogaby przyj nazw ***SendDefaultLangID*** bd藕 ***RetrieveDefaultLangID***.

### DllMain

Aby dowiedzie si ile wywoa ma `DllMain` najlepszym rozwizaniem jest stworzenie grafu np. z takimi ustawieniami:

![User Graph](img/28.png)

DllMain u偶ywa bezporednio **7 funkcji**:

![Graph DllMain Recursion 1](img/29.png)

U偶ywajc gbokoci 2 (*Je偶eli nie popeniem bdu w liczeniu*) u偶ywa **66 funkcji**:

![Graph DllMain Recursion 2](img/30.png)

### Sleep

Przed wywoaniem funkcji najpierw musi ona przyj parametry. Dzieje si to za pomoc `push`. Musimy w takim razie sprawdzi jak warto bdzie mia rejestr `eax`.

Zaczyna si od tego, 偶e do rejestru eax zapisana jest offset stringa ***"[This is CTI]30"***.

Do offsetu nastpnie jest dodana **warto 0Dh** (*13*) co sprawia, 偶e string to teraz ***"30"***.

`push eax` wrzuca `eax` na *stack*, gdzie nastpnie jest wywoana funkcja `atoi`, kt贸ra w jzyku *C++* zamienia string na liczb. Tak wic funckja zwraca **warto 30**. Wedug poni偶szej tabelki `eax` jest rejestrem, kt贸ry przychowuje pierwsz zwr贸con warto.

![Registry Usage Table](img/32.png)

Nastpnie warto zostaje pomno偶ona przez **3E8h** ($3 \cdot 16^2 + 14 \cdot 16 + 8$) czyli **1000**.

Ta warto jest przyjmowana jako parametr przez funckcj `Sleep`, kt贸ra przyjmuje czas w milisekundach. To oznacza, 偶e program pi przez ***30 sekund***.

### Socket

Funkcja Socek przyjmuje 3 parametry:

- int *af*
- int *type*
- int *protocol*

Wedug dokumentacji Microsoft  

- *af* oznacza address family
- *type* oznacza typ socketa
- *protocol* oznacza u偶yty protok贸

W tym miejscu odwoanie w pseudo C/C++ wygldao by tak:

```C
socket(2, 1, 6)
```

Co oznacza utworzony socket z address family **AF_INET** (*Adres IPv4*), type **SOCK_STREAM** (*Two way connection, przy AF_INET TCP*) i protokoem **IPPROTO_TCP**.

### in

Po wyszukaniu ka偶dej linii zawierajcej *EDh* znalazem tylko jeden adres w kt贸rym zostaa u偶yta funkcja `in`.

![in Address](img/34.png)

Funckcja `in` u偶ywa dw贸ch rejestr贸w: `eax` (*Magic Value*) oraz `dx` (*port*).

Po klikniciu na warto *564D5868h* i klikniciu klawisza R ukazuje nam si string *"VMXh"*, a w `edx` *"VX"*.

Po instrukcji `in` jest instrukcja `cmp ebx, 'VMXh'`, kt贸ra sprawdza czy otrzymano odpowied藕 od portu **VMware**.

Program jest zatem w stanie wykry obecno w maszynie wirtualnej.

Po wykonaniu funkcji znajduje si te偶 string *"Found Virtual Machine, Install Cancel."*.

### Adres 1001D988h

Pod tym adresem znajduj si losowe dane. Jednak w ksi偶ce odpowiednik tego zadania wskazuje na u偶ycie skryptu w pythonie. Niestety w *IDA Free* nie da si u偶ywa takich skrypt贸w. Skrypt jedyne co robi to xoruje ka偶dy znak z *55h*, wic zrobiem to rcznie u偶ywajc [Cyberchef](https://cyberchef.org/#recipe=From_Hex('Auto')XOR(%7B'option':'Hex','string':'55'%7D,'Standard',false)&input=MkQgMzEgM2EgM2EgMjcgNzUgCjNjIDI2IDc1IDIxIDNkIDNjIDI2IDc1IAozNyAzNCAzNiAzZSAzMSAzYSAzYSAyNyA3OSA3NSAKMjYgMjEgMjcgM2MgM2IgMzIgNzUgCjMxIDMwIDM2IDNhIDMxIDMwIDMxIDc1IAozMyAzYSAyNyA3NSAwNSAyNyAzNCAzNiAyMSAzYyAzNiAzNCAzOSA3NSAKMTggMzQgMzkgMjIgMzQgMjcgMzAgNzUgCjE0IDNiIDM0IDM5IDJjIDI2IDNjIDI2IDc1IAoxOSAzNCAzNyA3NSAKNmYgN2MgNjQgNjcgNjYgNjE).

![Cyberchef decoded](img/36.png)

## Laboratorium 4.2

### Struktura Main

Niestety *IDA Free* nie znajduje automatycznie funkcji `main`, wic musiaem znale藕 j rcznie.

Pozaadowaniu pliku z sygnaturami *FLIRT*, *IDA* rozpoznaa niekt贸re funkcje.

Aby znale藕 `Main` zaczem szukania od koca, poniewa偶 ka偶da funkcja `Main` zwraca **0** (*kiedy program zakoczy si bez bd贸w*). **0** bdzie si znajdowao w rejestrze `eax`, poniewa偶 jest to rejestr dla pierwszej zwracanej wartoci (*W tym wypadku r贸wnie偶 jedynej*).

Pierwsza funkcja od koca to `__XcptFilter`, kt贸ra zajmuje si ***exception handling***, a nastpnie funkcja `_exit`, kt贸ra ***zabija procesy***, wic nie s to interesujce mnie funckje.

Nastpna w kolejce jest funkcja `sub_401040`, kt贸ra przyjmuje **3** argumenty co wyglda obiecujco (*Wedug Microsoft main przyjmuje argumenty `argc`, `argv` oraz mo偶e zosta rozszerzony o argument zawierajcy zmienne rodowiskowe `envp`*).

Patrzc od koca na t funckj wida dwie r贸偶ne cie偶ki:

- W jednej jest instrukcja `xor eax, eax` co zeruje rejestr `eax`
- W drugiej rejestr jest instrukcja `mov eax, 1`, czyli `eax` posiada warto 1 (~~bd~~)

Po przeanalizowaniu funkcji `sub_402580`, nie znalazem rzeczy wskazujcych na to, 偶eby bya to funkcja `main`.

Co wicej bezporednio przed wywoaniem `sub_401040` wystpuj funkcje takie jak `__setargv, __setenvp` dziki czemu wiem, 偶e `sub_401040` jest funckj `main`.

![main function](img/38.png)  

![inside main function](img/39.png)  

Zagldajc do rodka funkcji `main` wid jedn funkcj `sub_401000`.
Funkcja jest bardzo prosta. Znajduje si w niej tylko jeden *if* oraz funkcja `InternetGetConnectionStatus`, kt贸ra nie robi nic innego ni偶 sprawdza czy system jest podczony do sieci.

Wedug dokumentacji Microsoftu funkcja zwraca **TRUE** (*1*), kiedy maszyna jest podczona do internetu, albo **FALSE** (*0*) kiedy nie jest.

W wypadku kiedy funkcja **zwr贸ci 1**, `cmp [ebp+InternetConnectionStatus], 0` (*nazwa zmiennej zmieniona przeze mnie*) ustawi flag **ZF = 0**, przez co program p贸jdzie cie偶k czerwon (*false*). Na koniec do rejestru `eax` przypisana jest **warto 1**.

Wracajc do funkcji `main` wida, 偶e `eax` jest **por贸wnany z 0** i w przypadku kiedy maszyna jest podczona do sieci funkcja `main` **zwr贸ci 1** (*Nie wiem dlaczego nie **0**, zwykle niezerowa warto oznacza bd*).

![sub_401000](img/37.png)

### 0x40105F

Funkcja wyglda dziwnie, ale uwag przykuwaj dwie funckje, kt贸re s funkcjami biblioteki ***Libc***: `__stbuf` oraz `__ftbuf`.

Po przeszukaniu internetu natknem si na [wpis na forum](https://social.msdn.microsoft.com/Forums/vstudio/en-US/838011e2-7404-4922-989e-3ceacd6e3127/how-about-the-function-stbufstdout-woks-?forum=vclanguage). Okazuje si, 偶e obie funkcje wykorzystywane s przez funkcj `printf`.

Najwidoczniej *IDA* nie rozpoznaa tej funkcji.

![sub_40105F](img/41.png)

![printf](img/40.png)

### Co si dzieje w programie

Wicej funkcji jest automatycznie wygenerowana przez kompilator (*Funkcje manipulujce stert `HeapCreate` `HeapDestroy`, `memset`*), wic program po prostu sprawdza czy maszyna jest podpita do internetu i w zale偶noci od tego wypisuje jeden ze string贸w.

- **Success: Internet Connection\n**
- **Error 1.1: No Internet\n**

## Laboratorium 4.3

### Main

Tak jak przy poprzednim ~~wirusie~~ programie zlokalizowaem funkcj `main` pod adresem **401130h**.

Pierwszy podprogram funkcji `main` to funkcja `sub_401000`. Jest to identyczna funkcja jak w poprzednim programie, kt贸ra sprawdza czy maszyna jest podczona do internetu.

Znajduje si w niej r贸wnie偶 tajemnicza funkcja `sub_40117F`, kt贸ra jest funkcj `printf`.

### sub_40117F

Opisane wy偶ej 

### Drugi podprogram

Drugi podprogram to funkcja `sub_401040`.

Wywouje ona funkcj `InternetOpenA`, kt贸ra otwiera przegldark (w tym przypadku *Internet Explorer 7.5/pma*). Funkcja nastpnie zwraca *Handle* do otwartej przegldarki.

Nastpna funkcja to `InterenOpenUrlA`, kt贸ra przyjmuje wczeniej zwr贸cony *Handle* oraz URL ***`http://www.practicalmalwareanalysis.com/cc.htm`***.
W wypadku kiedy nie uda si poczy ze stron Handle jest zamykana.

Po poczeniu ze stron program odczytuje jej zawarto za pomoc `InternetReadFile`. Zawarto jest zapisana do bufora pod adresem **`[ebp+Buffer]`**, a ilo bajt贸w odczytanych pod adresem **`[ebp+dwNumberOfBytesRead]`**. Funkcja odczytuje 200h bajt贸w czyli 512 bajt贸w.

Nastpnie mamy kilka por贸wna bajt贸w z bufora. zmienne *`var_20F`* do *`var_20D`* odpowiadaj kolejnym bajtom z bufora poniewa偶 bufor znajduje si na **pozycji -210**. Dziki temu wiemy, 偶e bufor zaczyna si od `<!--` czyli od pocztku **komentarza html**. Je偶eli kt贸ry z bajt贸w nie bdzie si zgadza, funkcja zwraca bd ***Error 2.3: Fail to get command\n***. Na koniec pity znak z bufora jest zapisany do rejestru `al`, a nastpnie zwr贸cony przez t funkcj.

![Second function](img/42.png)

![InternetOpenA](img/43.png)

![InternetReadFile](img/44.png)

### Indykatory sieciowe

Dwa indykatory sieciowe to przegldarka `Internet Explorer 7.5/pma` oraz adres `http://practicalmalwareanalysis.com/cc.htm`.

### Dziaanie

Wirus najpierw sprawdza czy maszyna jest poczona z internetem.

Je偶eli tak to wcza przegldark, czy si ze stron internetow i nastpnie pobiera z niej okrelon zawarto.

Na koniec program wypisuje jaka to komenda `Success Parsed command is %c\n`.

Na koniec program jest upiony przez **0EA60h** milisekund czyli **jedn minut**.

Program koczy swoje dziaanie.
