# Zaawansowana Analiza Statyczna

> TODO  
> Wstęp  
> Hashe

## Wstęp

## Table Of Contents

- [Zaawansowana Analiza Statyczna](#zaawansowana-analiza-statyczna)
  - [Wstęp](#wstęp)
  - [Table Of Contents](#table-of-contents)
  - [Hashe](#hashe)
  - [Struct Cheatsheet](#struct-cheatsheet)
    - [if statement](#if-statement)
    - [Nested if statement](#nested-if-statement)
    - [for loop](#for-loop)
  - [Laboratorium 4.1](#laboratorium-41)
    - [Adres DllMain](#adres-dllmain)
    - [Adres gethostbyname](#adres-gethostbyname)
    - [Wywołania gethostbyname](#wywołania-gethostbyname)
    - [DNS Request](#dns-request)
    - [Zmienne lokalne 10001656h](#zmienne-lokalne-10001656h)
    - [Parametry 10001656h](#parametry-10001656h)
    - [Adres \\cmd.exe /c](#adres-cmdexe-c)
    - [Co się dzieje w otoczeniu tego adresu](#co-się-dzieje-w-otoczeniu-tego-adresu)
    - [Zmienna dword\_1008E5C4](#zmienna-dword_1008e5c4)
    - [Adres 1000FF58h](#adres-1000ff58h)
    - [Eksport PLIST](#eksport-plist)
    - [sub\_10004E79](#sub_10004e79)
    - [DllMain](#dllmain)
  - [Laboratorium 4.2](#laboratorium-42)
  - [Laboratorium 4.3](#laboratorium-43)

## Hashe

| Plik | SHA-256 | VirusTotal |
| ---- | ------- | ---------- |
| Lab04-01.dll
| Lab04-01.py
| Lab05-01.exe
| Lab05-02.exe
| Lab05-03.exe
| Lab05-04.exe
| Lab05-05.exe

## Struct Cheatsheet

### if statement

Prosta struktura - porównywanie dwóch wartości, a następnie skok warunkowy

```asm
mov eax sth1
cmp eax sth2
jnz loc
```

### Nested if statement

2 zagnieżdżone ify dają 4 różne ścieżki:  

- Oba będą prawdziwe
- Tylko pierwszy będzie prawdziwy
- Tylko drugi będzie prawdziwy
- Żaden nie będzie prawdziwy

Komplikuje to strukturę kodu, lecz pojawi się sporo porównań i skoków warunkowych np.

```asm
cmp ... ...
jnz loc_1
cmp ... ...
jnz loc_2
...
jmp loc_4

loc_1:
...
loc_2:
...

...
loc_4:
*code continnues*
```

### for loop

Pętla for inicjuje wartość początkową i dopóki nie spełni się określowy warunek kod będzie skakał do tego samego miejsca (jak w pętli :P)

Przykład:

```asm
mov [ebp+var_ini], 0 ; [] oznacza lokalizację w pamięci
jmp loc_1

loc_2: ; inkrementacja
mov eax, [ebp+var_ini]
add eax, 1
mov [ebp+var_ini], eax

loc_1: ; kod w pętli
cmp [ebp+var], 20h ; wartość końcowa
jge loc_3
...
jmp loc_2
```

## Laboratorium 4.1

### Adres DllMain

Adres **DllMain** znajduje się na pozycji *000000001001516Dh*  
![DllMain Adress](img/1.png)  

### Adres gethostbyname

Funkcja **gethostbyname** znajduje się pod adresem *00000000100163CCh*  
![gethosybyname Adress](img/2.png)  

### Wywołania gethostbyname

Funkcja **gethostbyname** została wywołana 18 razy  
![gethostbyname xrefs](img/3.png)  

### DNS Request

Przed wykonaniem funkcji do rejestru jest zapisana zmienna *[This is RDO]pics.practicalmalwareanalysis.com*, a następnie została przesunięta o 0Dh  znaków, czyli 13 co daje ***pics.practicalmalwareanalysis.com***  
![DNS Request](img/4.png)  
![off_10019040](img/5.png)  

### Zmienne lokalne 10001656h

IDA rozpoznała dla funkcji *sub_10001656* **23** zmienne lokalne (offset ujemny, ponieważ są na stacku)  
![Local Variables and Parameters table](img/8.png)  

### Parametry 10001656h

Funkcja *sub_10001656* posiada **jeden** parametr (offset dodatni)
![sub_10001656 Local Variables and Parameter](img/6.png)  

### Adres \cmd.exe /c

String *\cmd.exe /c* znajduje się pod adresem **10095B34**

### Co się dzieje w otoczeniu tego adresu

Przeglądając graf na samym początku tej funkcji znajduje się duży string, który zawiera wiadomość. Znajdują się w niej informacje o ***szyfrowaniu magicznego numeru (Encrypt Magic Number)*** oraz ***Remote Shell Session***  
![Remote Shell Session](img/9.png)  
Program porównuje wersje systemu i w zależności od niej wywołuje *\cmd.exe /c* lub */command.exe /c*  
![Comparison](img/11.png)  
dwPlatformId równe 2 oznacza VER_PLATFORM_WIN32_NT co oznacza, że system jest Windows NT lub nowszy  
![dwPlatformId](img/13.png)  
![cmd/command](img/10.png)  
*/c* jako opcja oznacza, że wykona się komenda podana w stringu  
Program łączy stringi za pomocą funkcji ***strcat***  
![strcat](img/12.png)  
Dalej w funkcji znajdują się stringi takie jak:

- quit
- exit
- cd
- enmagic
- language
- install
- host
- inject

Najprawdopodbniej są to komendy, ze wzglęgu na wcześniejszą wiadomość z ***Remote Shell Session***

### Zmienna dword_1008E5C4

Zmienna dword_1008E5C4 została opisana [powyżej](#co-się-dzieje-w-otoczeniu-tego-adresu)

### Adres 1000FF58h

Jeżeli porównanie *'robotwork'* zwróci zero (eax będzie miało tą samą wartość) skok warunkowy nie wykona się i program będzie wykonywał się dalej (w tym przypadku pójdzie ścieżką czerwoną w lewo)  
![robotwork](img/14.png)  
Wykona się tam funkcja *sub100052A2*, która przyjmuje socket jako argument  
![sub_100052A2 function](img/15.png)  
Funkcja ta wykonuje następujące operacje:

- Otwiera rejestr ***HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion***
- Następnie klucz Worktime/Worktimes
- Z tego klucza wyciąga informacje i wysyła je zdalnemu hostowi za pomocą funkcji *sub_100038EE*

![Registry Key](img/18.png)  
![Reg info sent](img/19.png)  

### Eksport PLIST

Na początku funkcja sprawdza wersję systemu, lecz tym razem sprawdzając czy Majorversion jest większa niż 5 (czyli wersja nowsza lub równa Windows 2000)
![Sysversion Check](img/16.png)  
![Sysversion Major Version](img/17.png)  
W tym miejscu funkcja sprawdza, czy jako parametr został podany string. W obu przypadkach obie funkcje enumerują Wszystkie atywne procesy. Na początku wykonuje snapshot procesów za pomocą ***CreateToolhelp32Snapshot***,  
![CreateToolhelp32Snapshot](img/22.png)  
***Process32First***, aby wyciągnąć ze snapshota pierwszy proces, a następnie w pętli while ***Process32Next***.  
![While loop](img/23.png)  
Funkcja pozyskuje również informacje o tym do jakiego pliku należy dany proces za pomocą ***GetModuleFileNameEx***, wszystko w czytelnym formacie  
![While loop](img/21.png)  

### sub_10004E79

Funkcja wywołuje funkcję ***GetSystemDefaultLangID***, która zwraca ID domyślnie ustawionego języka systemowego, a następnie go wysyła zdalnemu hostowi  
![GetSystemDefaultLangID](img/24.png)  
Wszystkie ID są rozpisane przez Microsoft [tutaj](https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-LCID/%5bMS-LCID%5d.pdf)  
Dla przykładu język polski ma przypisane ID **0x0015** lub **0x0415**, a angielski **0x0009**, **0x0409** (odmiana amerykańska) lub **0x0809** (odmiana brytyjska) itd.  

Funkcja mogłaby przyjąć nazwę ***SendDefaultLangID*** bądź ***RetrieveDefaultLangID***

### DllMain

DllEntryPoint używa funkcji:

- sub_1000D02E

## Laboratorium 4.2

## Laboratorium 4.3
